# U3d_NakusiTest

Сделать сцену - замкнутое пространство, в котором рандомно спавнятся какие-либо персонажи и падают бомбы, которые могут наносить урон. Персонаж может получить определенное кол-во урона, после чего погибает.  

В пространстве рандомно расположены стены.   Плюсом будет поддержка разного типа бомб, а также поддержка зависимости урона от "дырок" в стенах. Дырка - это расстояние между стенами.

Стены и дырки в стенах - опционально, можно не делать. 
!Украшательства не важны: персонаж может быть квадрат, бомба кружок

!На что смотрим!: 
1. Декомпозиция задачи
2. Связи между слоями.
3. Дорабатываемость и устойчивость к изменениям.

Review:

1. Слабая декомпозиция задачи, по сути выделены Spawner'ы и бизнес-сущности (бомба, персонаж, стена и т.д.). 
2. Слой представления и бизнес-логики слит воедино (используются монобехи, в которые всё зашито). 
3. Общение объектов идет через прямой вызов метода одного объекта - другим. 
Например, 
Bombs.cs:28 
c.SetDamage(_bombSettings.Damage); 
 
Тут получается, что кто-то будет вызывать метод SetDamage извне, тем самым нарушая абстракцию, снижая инкапсуляцию и увеличивая связанность. 
 
4. Корутина без сохранения своего идентификатора. 
AbstractSpawner.cs:18 
StartCoroutine - возвращает Coroutine, который хорошо бы сохранять, чтобы можно было контролировать остановку корутины. 
 
5. GetComponent, лучше кешировать, т.к. поиск может занять продолжительное время. 
BombSpawner.cs:25 
var bomb = gameObject.GetComponent<Bomb>(); 
 
6. var hitColliders = new Collider[30], лучше 1 раз выделить массив, потом его переиспользовать, а тут получается, что каждый раз аллоцируем массив из 30 элементов. 
Bomb.cs:48 
 
7. c.TryGetComponent(out DamagebleMarker o), тут, в текущей ситуации, как раз лучше использовать интерфейс IDamageble. 
 
8. В проекте используется микс из делегатов и вызова public методов объектов, хорошо бы это было привести к единому виду. 
9. Можно было не делать AbstractSpawner и наследовать от него BombSpawner и CharacterSpawner, а сделать через Generic класс Spawner. 
 
10. _camera = Camera.main, применение неявной зависимости. 
HpBar.cs:11 
 
11. В текущей архитектуре, бизнес-объекты перегружены. Так, например, Character, знает про свой hpBar, в него встроены его стейт (_health), слой представления (_hpBar) и слой данных (_characterSettings). 
Такие вещи лучше разделять по слоям (каждый слой - свой класс/набор классов), каждый слой отвечает за что-то своё и настраивается, например в CharacterEntity. 
 
12. DamagebleMarker, OverlapableMarker выглядят избыточно, можно было использовать слои. 
 
В общем, тестовое считаю вполне хорошим, но с архитектурными огрехами. 
 
По архитектуре, я бы рекомендовал посмотреть в сторону Composition Root, Entity, Model, View. 
Entity - единица доменной области, например CharacterEntity. 
Model - бизнес-логика, например CharacterModel. 
View - слой представления, например CharacterView. 
 
Через Composition Root можно управлять жизненным циклом приложения. В каждом узле Composition Root можно создавать нужные Entity, которые в свою очередь создавали бы Model и View. 
Все связи можно сделать через абстрактные рычаги управления (делегаты, либо реактивные свойства) и эти связи передавать в конструктор для обычных классов, и в единственный метод, например SetContext, если это монобех. 
Все эти рычаги можно завернуть, например в структуру.
